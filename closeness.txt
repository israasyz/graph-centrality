#include <iostream>
#include <string>
#include <vector>
#include <limits.h>
#include <stdio.h>
using namespace std;

int minDistance(int *dist, bool *sptSet, int V) 
{ 
   // Initialize min value 
   int min = INT_MAX, min_index; 
   
   for (int v = 0; v < V; v++) 
     if (sptSet[v] == false && dist[v] <= min) 
         min = dist[v], min_index = v; 
   
   return min_index; 
} 

int shortest(int *dist, int V) 
{  
   //sum of shortest pathes to all nodes from node i 
   int pathes = 0; 
   for (int i = 0; i < V; i++) 
   { 
     pathes+=dist[i];
   }
   return pathes;
} 
   
int dijkstra(int **graph, int src, int V) 
{ 
     int *dist;     // The output array.  dist[i] will hold the shortest 
     dist = new int [V];              // distance from src to i 
     int pathes_per_node; 
     bool *sptSet; // sptSet[i] will be true if vertex i is included in shortest 
     sptSet = new bool [V];               // path tree or shortest distance from src to i is finalized 
   
     // Initialize all distances as INFINITE and stpSet[] as false 
     for (int i = 0; i < V; i++) 
        dist[i] = INT_MAX, sptSet[i] = false; 
   
     // Distance of source vertex from itself is always 0 
     dist[src] = 0; 
   
     // Find shortest path for all vertices 
     for (int count = 0; count < V-1; count++) 
     { 
       // Pick the minimum distance vertex from the set of vertices not 
       // yet processed. u is always equal to src in the first iteration. 
       int u = minDistance(dist, sptSet, V); 
   
       // Mark the picked vertex as processed 
       sptSet[u] = true; 
   
       // Update dist value of the adjacent vertices of the picked vertex. 
       for (int v = 0; v < V; v++) 
   
         // Update dist[v] only if is not in sptSet, there is an edge from  
         // u to v, and total weight of path from src to  v through u is  
         // smaller than current value of dist[v] 
         if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX  
                                       && dist[u]+graph[u][v] < dist[v]) 
            dist[v] = dist[u] + graph[u][v]; 
     } 
   
     pathes_per_node = shortest(dist, V);  
     return pathes_per_node; 
} 
   


int main()
{
 int n, m, u, v, w;
 int **matrix; //adjacency matrix
 float *closeness;
 
 cin>>n>>m;
 
 matrix = new int*[n];
 closeness = new float [n];
 
 for(int i=0; i<n;i++)
 {
  matrix[i] = new int [n];
  for (int j=0; j<n;j++)
  {
    matrix[i][j]=0;
  }
 } 
                                                                                                                 
 for (int i=0; i<m; i++)
 {  
    cin>>u>>v>>w;
    matrix[u][v]=w;
    matrix[v][u]=w;
 }

for(int i=0; i<n; i++) 
{
  closeness[i] = (n-1)/(float)dijkstra(matrix,i,n);
  cout<<closeness[i]<<endl;
}

return 0; 
 
}